[{"title":"KNN实现简单数字识别（十折交叉验证）","url":"https://christopher-ppx.github.io/2020/03/12/KNN实现简单数字识别以及十折交叉验证/","content":"<h1 id=\"机器学习第一次实验的实验报告\"><a href=\"#机器学习第一次实验的实验报告\" class=\"headerlink\" title=\"机器学习第一次实验的实验报告\"></a>机器学习第一次实验的实验报告</h1><h2 id=\"一、-问题描述\"><a href=\"#一、-问题描述\" class=\"headerlink\" title=\"一、   问题描述\"></a>一、   问题描述</h2><ol>\n<li><p>用python或matlab编写一个KNN分类器，计算k=1，3，5时的分类精度；训练集为semeion_train.csv，测试集为semeion_test.csv。即使用python为工具熟悉KNN的分类算法，了解K值在此算法中对实验精度的影响。</p>\n</li>\n<li><p>在训练集上划分一个交叉验证集，用留一法或者十折交叉（二选一）的方式选择k值。与weka机器学习包或者Python机器学习包（二选一验证即可）中的KNN分类结果进行对比。即使用交叉验证的方式选择k值，并且对比实际效果与已有的机器学习包的对比效果。</p>\n</li>\n<li><p>将实验过程结果等图示展出，例如：画一个以k值为x轴，交叉验证集分类精度为y轴的曲线。即以一些自变量观察其对实验结果的影响。</p>\n</li>\n</ol>\n<h2 id=\"二、-knn算法解释\"><a href=\"#二、-knn算法解释\" class=\"headerlink\" title=\"二、   knn算法解释\"></a>二、   knn算法解释</h2><p>给定测试实例，基于某种距离度量找出训练集中与其最靠近的k个实例点，然后基于这k个最近邻的信息来进行预测。</p>\n<p>通常，在分类任务中可使用“投票法”，即选择这k个实例中出现最多的标记类别作为预测结果；还可基于距离远近进行加权平均或加权投票，距离越近的实例权重越大。</p>\n<p>k近邻法不具有显式的学习过程，事实上，它是懒惰学习（lazy learning）的著名代表，此类学习技术在训练阶段仅仅是把样本保存起来，训练时间开销为零，待收到测试样本后再进行处理。</p>\n<p>而在这一次的实验过程中涉及到的数据集主要是二维的，所以在使用距离计算时使用了欧式距离的方式。</p>\n<h2 id=\"三、-解决方法\"><a href=\"#三、-解决方法\" class=\"headerlink\" title=\"三、   解决方法\"></a>三、   解决方法</h2><ol>\n<li><p>根据第一部分的第一条的问题要求，以及本身提供的代码可以成功运行出当k值为1，2，3时，分类的精度分别是85.56%，85.56%，85.77%。根据这个结果大概可以得出当k值越大分类精度越大的结论；但是实际上不能简单的得到这个结论，在查阅资料的时候发现如果选择太大的k值，其学习的近似误差会增大，而这个问题的代价是不相似的训练实例也会对预测器起作用使得预测的结果发生错误，简单的k值的增大也就意味着整体模型的简单化。</p>\n</li>\n<li><p>第二层次的要求主要分析Main部分之后，选用十折交叉的方式，主要是在加载训练集的时候分成十个部分，设的k的取值范围是1至10，然后将十个部分做测试部分所求得的k值的精度存储为一个矩阵的模式，然后在每列取平均值，得出十个k的平均精度，选出精度最大的即是需要选择的k值。</p>\n</li>\n<li><p>第三个层次的要求较为有弹性，所以就想画出一个以k值为x轴，交叉验证集分类精度为y轴的曲线。</p>\n</li>\n</ol>\n<h2 id=\"四、-实验结果\"><a href=\"#四、-实验结果\" class=\"headerlink\" title=\"四、   实验结果\"></a>四、   实验结果</h2><h3 id=\"第一部分：\"><a href=\"#第一部分：\" class=\"headerlink\" title=\"第一部分：\"></a>第一部分：</h3><p>​    分类的精度分别是85.56%，85.56%，85.77%。</p>\n<h3 id=\"第二部分：\"><a href=\"#第二部分：\" class=\"headerlink\" title=\"第二部分：\"></a>第二部分：</h3><p>  自己手动写了十折交叉的部分，其实可以只做一次十折交叉检验，但是总觉得如果只做一次感觉意义不大，所以将训练集等分为10份用来交叉检验，主要实验的目的是：将数据分为十个部分以及选出一个合适的k值。分十个部分我采用了和原来代码中的loadData部分但是用了单独的一个函数KNN_kfold，在这个函数中利用二维数组的形式来将数据集存入数组，分别是train_data_array以及test_data_array这样就可以对应所在位置然后存储各种的精确度，然后求和，因为这个地方求不求平均数差别不大，所以只求了和。最后得出结论：</p>\n<p>​    k的取值为10.</p>\n<p>  而在对比的部分，我采用的是python的sklearn的机器学习包，这个包中提供了分割十份的方法，而且可以使用train_data[train_index]的方式很方便的对数据集进行使用，而令我意外的是，最终在使用sklearn的包进行十折交叉的结果与之前自己所写的结果相同，我推测是因为这个地方的分十份用的代码是：kfold = KFold(n_splits=10, shuffle=True)，这个方法对数据集的操作方式与我之前自己写的操作实际是一样的，如果采用别的分割方式应该可以更加多面客观的选取k值或者是对模型进行评价，因为自己没有对更多的分割方式进行实战所以不加以赘述，而我的实验的结果如下：（这里的main部分我保留了要求一的内容）</p>\n<p>​    k的取值任然是10.</p>\n<h3 id=\"第三部分：\"><a href=\"#第三部分：\" class=\"headerlink\" title=\"第三部分：\"></a>第三部分：</h3><p>只研究了以k值为x轴，分类精度为y轴的曲线：</p>\n<p>​    第一次上传，图片总是出问题，暂时留住这个坑以后填。</p>\n<h2 id=\"五、-核心代码\"><a href=\"#五、-核心代码\" class=\"headerlink\" title=\"五、   核心代码\"></a>五、   核心代码</h2><h3 id=\"第一部分\"><a href=\"#第一部分\" class=\"headerlink\" title=\"第一部分\"></a>第一部分</h3><p>​    不做说明。</p>\n<h3 id=\"第二部分上部分：\"><a href=\"#第二部分上部分：\" class=\"headerlink\" title=\"第二部分上部分：\"></a>第二部分上部分：</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 求出十折的k值  </span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">KNN_kfold</span><span class=\"params\">(train_data)</span>:</span>  </span><br><span class=\"line\">\t    train_data_array = [[]]  </span><br><span class=\"line\">\t    test_data_array = [[]]  </span><br><span class=\"line\">\t    train_label_array = [[]]  </span><br><span class=\"line\">\t    test_label_array = [[]]  </span><br><span class=\"line\">\t    hope = [[<span class=\"number\">0</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">11</span>)] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">11</span>)]  </span><br><span class=\"line\">\t    result = [<span class=\"number\">0</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">11</span>)]  </span><br><span class=\"line\">\t    <span class=\"comment\"># (train_data, test_data) = loadData()  </span></span><br><span class=\"line\">\t    a, b = np.shape(train_data)  </span><br><span class=\"line\">\t    <span class=\"comment\"># 设置出10个部分的验证以及训练集合  </span></span><br><span class=\"line\">\t    <span class=\"keyword\">for</span> number <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, <span class=\"number\">11</span>):  </span><br><span class=\"line\">\t        <span class=\"comment\"># train_data_array[number] = np.delete(train_data, [m*(number-1)//10, (m*number//10)-1], axis=0)  </span></span><br><span class=\"line\">\t        train_data_array.append(np.delete(train_data, [a*(number<span class=\"number\">-1</span>)//<span class=\"number\">10</span>, (a*number//<span class=\"number\">10</span>)<span class=\"number\">-1</span>], axis=<span class=\"number\">0</span>))  </span><br><span class=\"line\">\t        <span class=\"comment\"># test_data_array[number] = train_data[m*(number-1)//10: (m*number//10)-1]  </span></span><br><span class=\"line\">\t        test_data_array.append(train_data[a*(number<span class=\"number\">-1</span>)//<span class=\"number\">10</span>: (a*number//<span class=\"number\">10</span>)<span class=\"number\">-1</span>])  </span><br><span class=\"line\">\t        <span class=\"comment\"># train_label_array[number] = train_data_array[number][:, -1]  </span></span><br><span class=\"line\">\t        train_label_array.append(train_data_array[number][:, <span class=\"number\">-1</span>])  </span><br><span class=\"line\">\t        <span class=\"comment\"># test_label_array[number] = test_data_array[number][:, -1]  </span></span><br><span class=\"line\">\t        test_label_array.append(test_data_array[number][:, <span class=\"number\">-1</span>])  </span><br><span class=\"line\">\t    <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, <span class=\"number\">11</span>):  </span><br><span class=\"line\">\t        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, <span class=\"number\">11</span>):  </span><br><span class=\"line\">\t            m, n = np.shape(train_data_array[i])  </span><br><span class=\"line\">\t            correct_cnt, pre_label = getKNNPredictedLabel(train_data_array[i], test_data_array[i], train_label_array[i], test_label_array[i], k)  </span><br><span class=\"line\">\t            acc = correct_cnt / np.shape(test_data_array[i])[<span class=\"number\">0</span>]  </span><br><span class=\"line\">\t            hope[k][i] = acc * <span class=\"number\">100</span>  </span><br><span class=\"line\">\t    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, <span class=\"number\">11</span>):  </span><br><span class=\"line\">\t        <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, <span class=\"number\">11</span>):  </span><br><span class=\"line\">\t            result[i] += hope[k][i]  </span><br><span class=\"line\">\t    max_result = max(result)  </span><br><span class=\"line\">\t    max_index = max(enumerate(result))  </span><br><span class=\"line\">\t    <span class=\"keyword\">return</span> max_index</span><br></pre></td></tr></table></figure>\n\n<p>其中遇到过很多问题，主要是在python语言上的，如append的使用以及/和//在除法上的区别。</p>\n<h3 id=\"第二部分下部分：\"><a href=\"#第二部分下部分：\" class=\"headerlink\" title=\"第二部分下部分：\"></a>第二部分下部分：</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 十折验证  </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">knn_kfold</span><span class=\"params\">()</span>:</span>  </span><br><span class=\"line\">    hope = [[<span class=\"number\">0</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">11</span>)] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">11</span>)]  </span><br><span class=\"line\">    result = [<span class=\"number\">0</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">11</span>)]  </span><br><span class=\"line\">    (train_data, test_data) = loadData()  </span><br><span class=\"line\">    kfold = KFold(n_splits=<span class=\"number\">10</span>, shuffle=<span class=\"literal\">True</span>)  </span><br><span class=\"line\">    index = kfold.split(X=train_data)  </span><br><span class=\"line\">    <span class=\"comment\"># 以下的代码主要是用来测试是否正常分割的  </span></span><br><span class=\"line\">    <span class=\"comment\"># for train_index, test_index in index:  </span></span><br><span class=\"line\">    <span class=\"comment\">#     print(\"-------------------------------------------------\")  </span></span><br><span class=\"line\">    <span class=\"comment\">#     print(train_data[train_index])  # 注意如果a是datafram类型就得用a.iloc[tain_index], 因为a[train_index]会被认为是访问列  </span></span><br><span class=\"line\">    <span class=\"comment\">#     print(train_data[test_index])  </span></span><br><span class=\"line\">    i = <span class=\"number\">0</span>  </span><br><span class=\"line\">    <span class=\"comment\"># 算出精度值之和，得出最后所需要的k的值  </span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> train_index, test_index <span class=\"keyword\">in</span> index:  </span><br><span class=\"line\">        i = i + <span class=\"number\">1</span>  </span><br><span class=\"line\">        train_label = train_data[train_index][:, <span class=\"number\">-1</span>]  </span><br><span class=\"line\">        test_label = train_data[test_index][:, <span class=\"number\">-1</span>]  </span><br><span class=\"line\">        <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, <span class=\"number\">11</span>):  </span><br><span class=\"line\">            correct_cnt, pre_label = getKNNPredictedLabel(train_data[train_index], train_data[test_index], train_label, test_label, k)  </span><br><span class=\"line\">            acc = correct_cnt / np.shape(test_data)[<span class=\"number\">0</span>]  </span><br><span class=\"line\">            hope[k][i] = acc * <span class=\"number\">100</span>  </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, <span class=\"number\">11</span>):  </span><br><span class=\"line\">            <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, <span class=\"number\">11</span>):  </span><br><span class=\"line\">                result[i] += hope[k][i]  </span><br><span class=\"line\">        max_result = max(result)  </span><br><span class=\"line\">        max_index = max(enumerate(result))  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> max_index</span><br></pre></td></tr></table></figure>\n\n<p>这个部分与之前的不同主要是存在与数据集的切割的地方出现的，之后的代码的核心其实都大同小异，主要就是一个求和以及找出最大值的问题，但是在这里也出现过将train_index 当成train_data[train_index]的问题不过后来很快就发现了错误。</p>\n<h2 id=\"六、-实验分析及总结\"><a href=\"#六、-实验分析及总结\" class=\"headerlink\" title=\"六、   实验分析及总结\"></a>六、   实验分析及总结</h2><p>​    此次实验的三个部分是层层深入的，在第一部分花了很长时间去看代码，然后画出了流程之后在第二部分就开始在看教材和ppt外阅读了大量关于k折交叉检验的博客，同时也了解了python的一些基础的语法，这对于以后的学习是十分重要的。而且在写python代码的时候确实发现了这是一个需要特别细心的编程语言，因为只要格式不对也会有各种各样的报错，同时也了解了python语法上与c++的不同，如在使用i++的时候也踩过雷，第一次的实验的完成也增强了我学习机器学习的信心，可以说也是加强了查阅资料来解决问题的能力。</p>\n","categories":["机器学习"],"tags":["机器学习"]},{"title":"测试文章","url":"https://christopher-ppx.github.io/2020/03/11/测试文章/","content":"<h1 id=\"梅开二度\"><a href=\"#梅开二度\" class=\"headerlink\" title=\"梅开二度\"></a>梅开二度</h1><p>这是一个由态度的文章</p>\n","categories":[],"tags":["测试"]},{"title":"about","url":"https://christopher-ppx.github.io/about/index.html","content":"","categories":[],"tags":[]},{"title":"category","url":"https://christopher-ppx.github.io/category/index.html","content":"","categories":[],"tags":[]},{"title":"","url":"https://christopher-ppx.github.io/css/personal-style.css","content":"html.page-home {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background-image: url('/images/bg.jpg');\n  background-color: transparent;\n  background-size: cover;\n  background-position: center center;\n  background-repeat: no-repeat;\n  /*background: linear-gradient( #1abc9c, transparent), linear-gradient( 90deg, skyblue, transparent), linear-gradient( -90deg, coral, transparent);*/\n  /*background-blend-mode: screen;*/\n  /*background: linear-gradient(to left, #5f2c82, #49a09d);*/\n}","categories":[],"tags":[]},{"title":"project","url":"https://christopher-ppx.github.io/project/index.html","content":"","categories":[],"tags":[]},{"title":"link","url":"https://christopher-ppx.github.io/link/index.html","content":"","categories":[],"tags":[]},{"title":"search","url":"https://christopher-ppx.github.io/search/index.html","content":"","categories":[],"tags":[]},{"title":"tag","url":"https://christopher-ppx.github.io/tag/index.html","content":"","categories":[],"tags":[]}]